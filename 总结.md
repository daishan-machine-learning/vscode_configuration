# 1. Inheritence
## 1.1 基类指针和引用
总的来说，当基类指针指向派生类的时候，如果没有virtual，那么基类的指针和引用只能看到自己的部分。这其实有很多的缺陷，比如，当多个类继承同一个基类的时候，我们想写一个比较针对它们比较通用的函数，如果基类指针不能访问到子类部分，那我们就得依据每一个子类，重载一个函数，这是不能容忍的，太冗余了，我们希望基类可以访问子类的成员。

## 1.2 virtual function
 + 1.virtual function and polymorphism
 + 2.virtual resolve to “most-derived” version between Base and current derived object
 + 3.if a function is marked as virtual ,all matching overrides are alse considered virtual implicitly,even if they are not explicitly marked as such.
+ 4.在派生类中的虚函数的override中，返回类型也必须一致，不然将被编译器视为两个函数
+ 5.do not call virtual function from constructor or destructor
 原因是当你调用基类的构造函数的时候，派生类对象还没创建，而基类已经创建，这时在基类的构造函数中调用virtual function 会导致只能调用基类函数,对于析构函数，当然也是相似的道理，因为当基类的析构函数开始析构的时候，派生类对象的部分已经析构完毕，此时调用的virtual function就只能是基类的函数了，
 从这个知识点可以看出，virtual function的调用时程序运行时动态的，这种情况称为RTTI(runtime type information)
+ 6.析构函数的缺点: 相比一般的函数性能低，因为程序动态的找虚函数，然后，每个类对象还要分配一个额外的指针。
+ 7.派生类虚函数覆盖要求，返回类型和参数类型必须完全与基类一致，不然不是override，这是很严格的要求。

## 1.3 override final specifier and covariant return type

+ 之所以需要override，是因为，虚函数的覆盖，是要求返回类型和参数类型和const完全一致，
    但是在大型的程序中，我们有时没办法保证这一点，所以c++就推出了override,来显式的表明，
    该函数是某个基类虚函数的覆盖，如果出现不匹配的情况，或者基类压根就没有需要override的函数，
    编译器就会报错。



+ final specifier:
        final 用来表示当前函数不允许被override 或者是 当前类不允许被继承，final放置的位置是当前函数
        之后，或者是当前类之后。


+ covariant return type :协变返回类型
这是c++中唯一允许的返回类型不一致，也可被编译器认为match的virtual function override。
也就是:如果一个虚函数的返回类型是某个类Base的指针和引用，而该虚函数的覆盖版本返回的是
Base的派生类的指针和引用，这种情况被称为covariant return type
