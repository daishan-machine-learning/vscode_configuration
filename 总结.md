# 1. Inheritence
## 1.1 基类指针和引用
总的来说，当基类指针指向派生类的时候，如果没有virtual，那么基类的指针和引用只能看到自己的部分。这其实有很多的缺陷，比如，当多个类继承同一个基类的时候，我们想写一个比较针对它们比较通用的函数，如果基类指针不能访问到子类部分，那我们就得依据每一个子类，重载一个函数，这是不能容忍的，太冗余了，我们希望基类可以访问子类的成员。

## 1.2 virtual function
 + 1.virtual function and polymorphism
 + 2.virtual resolve to “most-derived” version between Base and current derived object
 + 3.if a function is marked as virtual ,all matching overrides are alse considered virtual implicitly,even if they are not explicitly marked as such.
+ 4.在派生类中的虚函数的override中，返回类型也必须一致，不然将被编译器视为两个函数
+ 5.do not call virtual function from constructor or destructor
 原因是当你调用基类的构造函数的时候，派生类对象还没创建，而基类已经创建，这时在基类的构造函数中调用virtual function 会导致只能调用基类函数,对于析构函数，当然也是相似的道理，因为当基类的析构函数开始析构的时候，派生类对象的部分已经析构完毕，此时调用的virtual function就只能是基类的函数了，
 从这个知识点可以看出，virtual function的调用时程序运行时动态的，这种情况称为RTTI(runtime type information)
+ 6.析构函数的缺点: 相比一般的函数性能低，因为程序动态的找虚函数，然后，每个类对象还要分配一个额外的指针。